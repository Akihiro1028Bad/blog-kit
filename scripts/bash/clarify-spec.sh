#!/bin/bash

# clarify-spec.sh
# Clarifies article specification by identifying and resolving ambiguities

set -e

REPO_ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
BLOGKIT_DIR="$REPO_ROOT/.blogkit"
CONSTITUTION_FILE="$BLOGKIT_DIR/memory/constitution.md"

# Get optional focus areas from arguments
FOCUS_AREAS="$*"

# Check prerequisites
PREREQ_OUTPUT=$(scripts/bash/check-prerequisites.sh --json --require-spec)
FEATURE_DIR=$(echo "$PREREQ_OUTPUT" | grep -o '"FEATURE_DIR": "[^"]*"' | cut -d'"' -f4)
SPEC_FILE=$(echo "$PREREQ_OUTPUT" | grep -o '"SPEC_FILE": "[^"]*"' | cut -d'"' -f4)

if [ -z "$FEATURE_DIR" ]; then
    echo "$PREREQ_OUTPUT"
    exit 1
fi

# Read spec.md
if [ ! -f "$SPEC_FILE" ]; then
    echo "{\"error\": \"spec.md not found: $SPEC_FILE\"}"
    exit 1
fi

SPEC_CONTENT=$(cat "$SPEC_FILE")

# Read constitution.md if available
CONSTITUTION_CONTENT=""
if [ -f "$CONSTITUTION_FILE" ]; then
    CONSTITUTION_CONTENT=$(cat "$CONSTITUTION_FILE")
fi

# Analyze spec.md for ambiguities
# 1. Find [NEEDS CLARIFICATION] markers (max 3)
CLARIFICATION_MARKERS=$(echo "$SPEC_CONTENT" | grep -o '\[NEEDS CLARIFICATION:[^\]]*\]' | head -3 || true)

# 2. Find "To be defined" placeholders
TO_BE_DEFINED=$(echo "$SPEC_CONTENT" | grep -n "To be defined" || true)

# 3. Count ambiguities
AMBIGUITY_COUNT=0
if [ -n "$CLARIFICATION_MARKERS" ]; then
    MARKER_COUNT=$(echo "$CLARIFICATION_MARKERS" | grep -c . || echo "0")
    AMBIGUITY_COUNT=$((AMBIGUITY_COUNT + MARKER_COUNT))
fi
if [ -n "$TO_BE_DEFINED" ]; then
    TBD_COUNT=$(echo "$TO_BE_DEFINED" | grep -c . || echo "0")
    AMBIGUITY_COUNT=$((AMBIGUITY_COUNT + TBD_COUNT))
fi

# Build JSON array for clarification markers (without jq)
CLARIFICATION_JSON="["
if [ -n "$CLARIFICATION_MARKERS" ]; then
    FIRST=true
    while IFS= read -r marker; do
        if [ -n "$marker" ]; then
            if [ "$FIRST" = true ]; then
                FIRST=false
            else
                CLARIFICATION_JSON="$CLARIFICATION_JSON,"
            fi
            # Escape quotes in marker
            ESCAPED_MARKER=$(echo "$marker" | sed 's/"/\\"/g')
            CLARIFICATION_JSON="$CLARIFICATION_JSON\"$ESCAPED_MARKER\""
        fi
    done <<< "$CLARIFICATION_MARKERS"
fi
CLARIFICATION_JSON="$CLARIFICATION_JSON]"

# Escape JSON strings
ESCAPED_FOCUS_AREAS=$(echo "$FOCUS_AREAS" | sed 's/"/\\"/g')
SPEC_PREVIEW=$(echo "$SPEC_CONTENT" | head -50 | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')

# Output JSON with analysis results
# The AI will use this information to generate clarification questions
cat <<EOF
{
  "FEATURE_DIR": "$FEATURE_DIR",
  "SPEC_FILE": "$SPEC_FILE",
  "HAS_CLARIFICATION_MARKERS": $([ -n "$CLARIFICATION_MARKERS" ] && echo "true" || echo "false"),
  "CLARIFICATION_MARKERS": $CLARIFICATION_JSON,
  "HAS_TO_BE_DEFINED": $([ -n "$TO_BE_DEFINED" ] && echo "true" || echo "false"),
  "TO_BE_DEFINED_COUNT": $AMBIGUITY_COUNT,
  "FOCUS_AREAS": "$ESCAPED_FOCUS_AREAS",
  "SPEC_CONTENT_PREVIEW": "$SPEC_PREVIEW"
}
EOF

# Note: The actual clarification questions will be generated by the AI
# based on this analysis. The AI should:
# 1. Read the full spec.md content
# 2. Identify ambiguities and undefined areas
# 3. Generate structured questions with suggested answers
# 4. Present questions to the user
# 5. Collect user responses
# 6. Update spec.md with clarifications

